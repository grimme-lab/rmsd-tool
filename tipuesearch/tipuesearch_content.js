var tipuesearch = {"pages":[{"title":" mctc-rmsd ","text":"mctc-rmsd Tool to calculate root mean square deviations between molecular structures. Getting Started Meson Create a new meson project and include rmsd either as git-submodule in your subprojects directory or create a wrap file to fetch it from upstream: [wrap-git] directory = mctc-rmsd url = https://github.com/grimme-lab/rmsd-tool revision = head The rmsd library depends on the MCTC-library and TOML-Fortran .\nYou might have to promote those dependencies to your subprojects by copying the wrap files from the rmsd subprojects. To load the project the necessary boilerplate code for subprojects is just rmsd_prj = subproject ( 'mctc-rmsd' , version : '>=0.1' , default_options : [ 'default_library=static' , ], ) rmsd_dep = rmsd_prj . get_variable ( 'rmsd_dep' ) Now you can add rmsd_dep to your dependencies and access the public API by the rmsd module. We recommend to set the default library type of rmsd to static when linking your applications or library against it.\nNote for library type both and shared rmsd will install itself along with your project. For more fine-tuned control you can access: the library target with rmsd_lib the private include dir of this target, containing the Fortran module files, with rmsd_inc the license files of rmsd with rmsd_lic If you are linking your application statically against rmsd and still want to distribute the license files of rmsd (thank you), just use install_data ( rmsd_prj . get_variable ( 'rmsd_lic' ), install_dir : get_option ( 'datadir' ) / 'licenses' / meson . project_name () / 'mctc-rmsd' , ) Fortran Package Manager (fpm) This project supports fpm as build system as well.\nJust add it to the dependencies in your fpm.toml file: [dependencies] [dependencies.mctc-rmsd] git = \"https://github.com/grimme-lab/rmsd-tool\" Developer Info Grimme group, Bonn","tags":"home","loc":"index.html"},{"title":"rmsd.f90 – mctc-rmsd","text":"Contents Modules rmsd Source Code rmsd.f90 Source Code ! This file is part of mctc-rmsd. ! SPDX-Identifier: LGPL-3.0-or-later ! ! mctc-rmsd is free software: you can redistribute it and/or modify it under ! the terms of the GNU Lesser General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! mctc-rmsd is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU Lesser General Public License for more details. ! ! You should have received a copy of the GNU Lesser General Public License ! along with mctc-rmsd.  If not, see <https://www.gnu.org/licenses/>. module rmsd use mctc_env , only : wp use mctc_io , only : structure_type use rmsd_ls , only : get_rmsd use rmsd_version , only : get_rmsd_version implicit none private public :: get_rmsd , get_rmsd_version interface get_rmsd module procedure :: get_rmsd_for_structure end interface get_rmsd contains pure subroutine get_rmsd_for_structure ( struc1 , struc2 , rmsd , gradient , trafo , mask ) !> Reference structure type ( structure_type ), intent ( in ) :: struc1 !> Molecular structure to compare against type ( structure_type ), intent ( in ) :: struc2 !> Root mean square deviation between the two structures real ( wp ), intent ( out ) :: rmsd !> Gradient of the RMSD w.r.t. the coordinates real ( wp ), intent ( out ), optional :: gradient (:, :) !> Rotation matrix between the two structures real ( wp ), intent ( out ), optional :: trafo (:, :) !> Atoms to include in the RMSD calculation logical , intent ( in ), optional :: mask (:) call get_rmsd ( struc1 % xyz , struc2 % xyz , rmsd , gradient , trafo , mask ) end subroutine get_rmsd_for_structure end module rmsd","tags":"","loc":"sourcefile/rmsd.f90.html"},{"title":"version.f90 – mctc-rmsd","text":"Contents Modules rmsd_version Source Code version.f90 Source Code ! This file is part of mctc-rmsd. ! SPDX-Identifier: LGPL-3.0-or-later ! ! mctc-rmsd is free software: you can redistribute it and/or modify it under ! the terms of the GNU Lesser General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! mctc-rmsd is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU Lesser General Public License for more details. ! ! You should have received a copy of the GNU Lesser General Public License ! along with mctc-rmsd.  If not, see <https://www.gnu.org/licenses/>. !> Versioning information on this library. module rmsd_version implicit none private public :: rmsd_version_string , rmsd_version_compact public :: get_rmsd_version !> String representation of the mctc-rmsd version character ( len =* ), parameter :: rmsd_version_string = \"0.1.1\" !> Numeric representation of the mctc-rmsd version integer , parameter :: rmsd_version_compact ( 3 ) = [ 0 , 1 , 1 ] contains !> Getter function to retrieve mctc-rmsd version subroutine get_rmsd_version ( major , minor , patch , string ) !> Major version number of the mctc-rmsd version integer , intent ( out ), optional :: major !> Minor version number of the mctc-rmsd version integer , intent ( out ), optional :: minor !> Patch version number of the mctc-rmsd version integer , intent ( out ), optional :: patch !> String representation of the mctc-rmsd version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = rmsd_version_compact ( 1 ) end if if ( present ( minor )) then minor = rmsd_version_compact ( 2 ) end if if ( present ( patch )) then patch = rmsd_version_compact ( 3 ) end if if ( present ( string )) then string = rmsd_version_string end if end subroutine get_rmsd_version end module rmsd_version","tags":"","loc":"sourcefile/version.f90.html"},{"title":"ls.f90 – mctc-rmsd","text":"Contents Modules rmsd_ls Source Code ls.f90 Source Code ! This file is part of mctc-rmsd. ! SPDX-Identifier: LGPL-3.0-or-later ! ! Copyright (C) 2004, 2005 Chaok Seok, Evangelos Coutsias and Ken Dill !      UCSF, Univeristy of New Mexico, Seoul National University ! Written by Chaok Seok and Evangelos Coutsias 2004. ! ! Modified and adapted for mctc-rmsd by Sebastian Ehlert. ! ! This library is free software; you can redistribute it and/or ! modify it under the terms of the GNU Lesser General Public ! License as published by the Free Software Foundation; either ! version 2.1 of the License, or (at your option) any later version. ! ! This library is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU ! Lesser General Public License for more details. ! ! You should have received a copy of the GNU Lesser General Public ! License along with this library; if not, write to the Free Software ! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA !> Implementation of the least-square RMSD fit of two structures module rmsd_ls use mctc_env_accuracy , only : dp implicit none private public :: get_rmsd !> Overload to allow extending the interface later interface get_rmsd module procedure :: get_rmsd_for_coord end interface get_rmsd contains !> This subroutine calculates the least-square RMSD of two coordinate !> sets coord1(3, n) and coord2(3, n) using a method based on quaternion. pure subroutine get_rmsd_for_coord ( coord1 , coord2 , rmsd , gradient , trafo , mask ) !> Coordinates of the reference structure real ( dp ), intent ( in ) :: coord1 (:, :) !> Coordinates of the structure to compare real ( dp ), intent ( in ) :: coord2 (:, :) !> Root mean square deviation between the input structure real ( dp ), intent ( out ) :: rmsd !> Derivative of the RMSD w.r.t. the coordinates of the reference structure real ( dp ), intent ( out ), optional :: gradient (:, :) !> Transformation matrix to rotate into reference structure real ( dp ), intent ( out ), optional :: trafo (:, :) !> Atoms to include into RMSD calculation logical , intent ( in ), optional :: mask (:) integer :: n , m , i , j real ( dp ), allocatable :: x (:, :), y (:, :) real ( dp ), allocatable :: xi (:), yi (:) real ( dp ) :: x_center ( 3 ), y_center ( 3 ) real ( dp ) :: x_norm , y_norm , lambda real ( dp ) :: Rmatrix ( 3 , 3 ), tmp ( 3 ) real ( dp ) :: S ( 4 , 4 ), q ( 4 ) if ( present ( mask )) then m = min ( size ( coord1 , 2 ), size ( coord2 , 2 ), size ( mask )) n = count ( mask ( 1 : m )) allocate ( x ( 3 , n ), y ( 3 , n ), xi ( n ), yi ( n )) ! make copies of the original coordinates j = 0 do i = 1 , m if ( mask ( i )) then j = j + 1 x (:, j ) = coord1 (:, i ) y (:, j ) = coord2 (:, i ) end if end do else n = min ( size ( coord1 , 2 ), size ( coord2 , 2 )) allocate ( x ( 3 , n ), y ( 3 , n ), xi ( n ), yi ( n )) ! make copies of the original coordinates x (:, 1 : n ) = coord1 (:, 1 : n ) y (:, 1 : n ) = coord2 (:, 1 : n ) end if ! calculate the barycenters x_center (:) = 0.0_dp y_center (:) = 0.0_dp do i = 1 , n x_center (:) = x_center (:) + x (:, i ) / real ( n , dp ) y_center (:) = y_center (:) + y (:, i ) / real ( n , dp ) end do ! calculate centroidal coordinates and the norms x_norm = 0.0_dp y_norm = 0.0_dp do i = 1 , n x (:, i ) = x (:, i ) - x_center y (:, i ) = y (:, i ) - y_center x_norm = x_norm + dot_product ( x (:, i ), x (:, i )) y_norm = y_norm + dot_product ( y (:, i ), y (:, i )) end do ! calculate the R matrix Rmatrix (:, :) = matmul ( x , transpose ( y )) ! S matrix S ( 1 , 1 ) = Rmatrix ( 1 , 1 ) + Rmatrix ( 2 , 2 ) + Rmatrix ( 3 , 3 ) S ( 2 , 1 ) = Rmatrix ( 2 , 3 ) - Rmatrix ( 3 , 2 ) S ( 3 , 1 ) = Rmatrix ( 3 , 1 ) - Rmatrix ( 1 , 3 ) S ( 4 , 1 ) = Rmatrix ( 1 , 2 ) - Rmatrix ( 2 , 1 ) S ( 1 , 2 ) = S ( 2 , 1 ) S ( 2 , 2 ) = Rmatrix ( 1 , 1 ) - Rmatrix ( 2 , 2 ) - Rmatrix ( 3 , 3 ) S ( 3 , 2 ) = Rmatrix ( 1 , 2 ) + Rmatrix ( 2 , 1 ) S ( 4 , 2 ) = Rmatrix ( 1 , 3 ) + Rmatrix ( 3 , 1 ) S ( 1 , 3 ) = S ( 3 , 1 ) S ( 2 , 3 ) = S ( 3 , 2 ) S ( 3 , 3 ) = - Rmatrix ( 1 , 1 ) + Rmatrix ( 2 , 2 ) - Rmatrix ( 3 , 3 ) S ( 4 , 3 ) = Rmatrix ( 2 , 3 ) + Rmatrix ( 3 , 2 ) S ( 1 , 4 ) = S ( 4 , 1 ) S ( 2 , 4 ) = S ( 4 , 2 ) S ( 3 , 4 ) = S ( 4 , 3 ) S ( 4 , 4 ) = - Rmatrix ( 1 , 1 ) - Rmatrix ( 2 , 2 ) + Rmatrix ( 3 , 3 ) ! Calculate eigenvalues and eigenvectors, and ! take the maximum eigenvalue lambda and the corresponding eigenvector q. call dstmev ( S , lambda , q ) if ( present ( trafo ) . or . present ( gradient )) then ! convert quaternion q to rotation matrix call rotation_matrix ( q , Rmatrix ) if ( present ( trafo )) trafo (:, :) = Rmatrix end if ! RMS Deviation, small number added to avoid NAN in gradient, SG 12/18 rmsd = sqrt ( max ( 0.0_dp , (( x_norm + y_norm ) - 2.0_dp * lambda )) / real ( n , dp )) if ( present ( gradient )) then if ( present ( mask )) then j = 0 gradient (:, :) = 0.0_dp do i = 1 , n if ( mask ( i )) then j = j + 1 tmp (:) = matmul ( transpose ( Rmatrix ), y (:, i )) gradient (:, j ) = ( x (:, i ) - tmp ) / max ( epsilon ( 0.0_dp ), rmsd * real ( n , dp )) else end if end do else do i = 1 , n tmp (:) = matmul ( transpose ( Rmatrix ), y (:, i )) gradient (:, i ) = ( x (:, i ) - tmp ) / max ( epsilon ( 0.0_dp ), rmsd * real ( n , dp )) end do end if end if end subroutine get_rmsd_for_coord !> This subroutine constructs rotation matrix U from quaternion q. pure subroutine rotation_matrix ( q , U ) real ( dp ), intent ( in ) :: q (:) real ( dp ), intent ( out ) :: U (:, :) real ( dp ) :: q0 , q1 , q2 , q3 , b0 , b1 , b2 , b3 real ( dp ) :: q00 , q01 , q02 , q03 , q11 , q12 , q13 , q22 , q23 , q33 q0 = q ( 1 ) q1 = q ( 2 ) q2 = q ( 3 ) q3 = q ( 4 ) b0 = 2.0_dp * q0 b1 = 2.0_dp * q1 b2 = 2.0_dp * q2 b3 = 2.0_dp * q3 q00 = b0 * q0 - 1.0_dp q01 = b0 * q1 q02 = b0 * q2 q03 = b0 * q3 q11 = b1 * q1 q12 = b1 * q2 q13 = b1 * q3 q22 = b2 * q2 q23 = b2 * q3 q33 = b3 * q3 U ( 1 , 1 ) = q00 + q11 U ( 1 , 2 ) = q12 - q03 U ( 1 , 3 ) = q13 + q02 U ( 2 , 1 ) = q12 + q03 U ( 2 , 2 ) = q00 + q22 U ( 2 , 3 ) = q23 - q01 U ( 3 , 1 ) = q13 - q02 U ( 3 , 2 ) = q23 + q01 U ( 3 , 3 ) = q00 + q33 end subroutine rotation_matrix !> A simple subroutine to compute the leading eigenvalue and eigenvector !> of a symmetric, traceless 4x4 matrix A by an inverse power iteration: !> (1) the matrix is converted to tridiagonal form by 3 Givens !> rotations;  V*A*V' = T !> (2) Gershgorin's theorem is used to estimate a lower !> bound for the leading negative eigenvalue: !> lambda_1 > g=min(T11-t12, -t21+T22-t23, -t32+T33-t34, -t43+T44) !>          = !> where tij=abs(Tij) !> (3) Form the positive definite matrix !>     B = T-gI !> (4) Use svd (algorithm svdcmp from \"Numerical Recipes\") !>     to compute eigenvalues and eigenvectors for SPD matrix B !> (5) Shift spectrum back and keep leading singular vector !>     and largest eigenvalue. !> (6) Convert eigenvector to original matrix A, through !>     multiplication by V'. pure subroutine dstmev ( A , lambda , evec ) real ( dp ), intent ( inout ) :: A ( 4 , 4 ) real ( dp ), intent ( out ) :: evec ( 4 ) real ( dp ), intent ( out ) :: lambda real ( dp ) :: T ( 4 , 4 ), V ( 4 , 4 ), SV ( 4 , 4 ) integer :: i integer :: max_loc ( 1 ) ! must be an array real ( dp ) :: SW ( 4 ) real ( dp ) :: rv1 ( 8 ) ! (I). Convert to tridiagonal form, keeping similarity transform ! (a product of 3 Givens rotations) call givens4 ( A , T , V ) ! (II) Estimate lower bound of smallest eigenvalue by Gershgorin's theorem lambda = min ( T ( 1 , 1 ) - abs ( T ( 1 , 2 )), - abs ( T ( 2 , 1 )) + T ( 2 , 2 ) - abs ( T ( 2 , 3 )), & - abs ( T ( 3 , 2 )) + T ( 3 , 3 ) - abs ( T ( 3 , 4 )), - abs ( T ( 4 , 3 )) + T ( 4 , 4 )) ! (III). Form positive definite matrix     T <== lambda*I - T do i = 1 , 4 T ( i , i ) = T ( i , i ) - lambda enddo ! (IV). Compute singular values/vectors of SPD matrix B call svdcmp ( 4 , T , 4 , 4 , SW , SV , rv1 ) !(V). Shift spectrum back max_loc = maxloc ( SW ) lambda = SW ( max_loc ( 1 )) + lambda ! (VI). Convert eigenvector to original coordinates: (V is transposed!) evec = matmul ( V , SV (:, max_loc ( 1 ))) end subroutine dstmev !> Performs givens rotations to reduce symmetric 4x4 matrix to tridiagonal pure subroutine givens4 ( S , T , V ) real ( dp ), intent ( in ) :: S ( 4 , 4 ) real ( dp ), intent ( out ) :: T ( 4 , 4 ) real ( dp ), intent ( out ) :: V ( 4 , 4 ) real ( dp ) :: c1 , c2 , c3 , s1 , s2 , s3 , r1 , r2 , r3 , c1c2 , s1c2 T = S V = 0.0_dp ! Zero out entries T(4, 1) and T(1, 4) ! compute cos and sin of rotation angle in the 3-4 plane r1 = pythag ( T ( 3 , 1 ), T ( 4 , 1 )) if ( r1 . ne . 0.0_dp ) then c1 = T ( 3 , 1 ) / r1 s1 = T ( 4 , 1 ) / r1 V ( 3 , 3 ) = c1 V ( 3 , 4 ) = s1 V ( 4 , 3 ) = - s1 V ( 4 , 4 ) = c1 T ( 3 , 1 ) = r1 T ( 4 , 1 ) = 0.0_dp T ( 3 : 4 , 2 : 4 ) = matmul ( V ( 3 : 4 , 3 : 4 ), T ( 3 : 4 , 2 : 4 )) T ( 1 : 2 , 3 : 4 ) = transpose ( T ( 3 : 4 , 1 : 2 )) T ( 3 : 4 , 3 : 4 ) = matmul ( T ( 3 : 4 , 3 : 4 ), transpose ( V ( 3 : 4 , 3 : 4 ))) else c1 = 1.0_dp s1 = 0.0_dp endif ! Zero out entries T(3, 1) and T(1, 3) ! compute cos and sin of rotation angle in the 2-3 plane r2 = pythag ( T ( 3 , 1 ), T ( 2 , 1 )) if ( r2 . ne . 0.0_dp ) then c2 = T ( 2 , 1 ) / r2 s2 = T ( 3 , 1 ) / r2 V ( 2 , 2 ) = c2 V ( 2 , 3 ) = s2 V ( 3 , 2 ) = - s2 V ( 3 , 3 ) = c2 T ( 2 , 1 ) = r2 T ( 3 , 1 ) = 0.0_dp T ( 2 : 3 , 2 : 4 ) = matmul ( V ( 2 : 3 , 2 : 3 ), T ( 2 : 3 , 2 : 4 )) T ( 1 , 2 : 3 ) = T ( 2 : 3 , 1 ) T ( 4 , 2 : 3 ) = T ( 2 : 3 , 4 ) T ( 2 : 3 , 2 : 3 ) = matmul ( T ( 2 : 3 , 2 : 3 ), transpose ( V ( 2 : 3 , 2 : 3 ))) else c2 = 1.0_dp s2 = 0.0_dp endif ! Zero out entries T(4, 2) and T(2, 4) ! compute cos and sin of rotation angle in the 3-4 plane r3 = pythag ( T ( 4 , 2 ), T ( 3 , 2 )) if ( r3 . ne . 0.0_dp ) then c3 = T ( 3 , 2 ) / r3 s3 = T ( 4 , 2 ) / r3 V ( 3 , 3 ) = c3 V ( 3 , 4 ) = s3 V ( 4 , 3 ) = - s3 V ( 4 , 4 ) = c3 T ( 3 , 2 ) = r3 T ( 4 , 2 ) = 0.0_dp T ( 3 : 4 , 3 : 4 ) = matmul ( V ( 3 : 4 , 3 : 4 ), T ( 3 : 4 , 3 : 4 )) T ( 1 : 2 , 3 : 4 ) = transpose ( T ( 3 : 4 , 1 : 2 )) T ( 3 : 4 , 3 : 4 ) = matmul ( T ( 3 : 4 , 3 : 4 ), transpose ( V ( 3 : 4 , 3 : 4 ))) else c3 = 1.0_dp s3 = 0.0_dp endif ! Compute net rotation matrix (accumulate similarity for evec. computation) ! To save transposing later, This is the transpose! V ( 1 , 1 ) = 1.0_dp V ( 1 , 2 : 4 ) = 0.0_dp V ( 2 : 4 , 1 ) = 0.0_dp V ( 2 , 2 ) = c2 V ( 3 , 2 ) = c1 * s2 V ( 4 , 2 ) = s1 * s2 c1c2 = c1 * c2 s1c2 = s1 * c2 V ( 2 , 3 ) = - s2 * c3 V ( 3 , 3 ) = c1c2 * c3 - s1 * s3 V ( 4 , 3 ) = s1c2 * c3 + c1 * s3 V ( 2 , 4 ) = s2 * s3 V ( 3 , 4 ) = - c1c2 * s3 - s1 * c3 V ( 4 , 4 ) = - s1c2 * s3 + c1 * c3 end subroutine givens4 pure subroutine svdcmp ( mmax , a , m , n , w , v , rv1 ) integer , intent ( in ) :: mmax integer , intent ( in ) :: m integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: a ( mmax , * ) real ( dp ), intent ( inout ) :: v ( mmax , * ) real ( dp ), intent ( inout ) :: w ( * ) real ( dp ), intent ( inout ) :: rv1 ( * ) integer :: i , its , j , jj , k , l , nm real ( dp ) :: anorm , c , f , g , h , s , scale , x , y , z g = 0.0_dp scale = 0.0_dp anorm = 0.0_dp do i = 1 , n l = i + 1 rv1 ( i ) = scale * g g = 0.0_dp s = 0.0_dp scale = 0.0_dp if ( i . le . m ) then do k = i , m scale = scale + abs ( a ( k , i )) end do if ( scale . ne . 0.0_dp ) then do k = i , m a ( k , i ) = a ( k , i ) / scale s = s + a ( k , i ) * a ( k , i ) end do f = a ( i , i ) g = - sign ( sqrt ( s ), f ) h = f * g - s a ( i , i ) = f - g do j = l , n s = 0.0_dp do k = i , m s = s + a ( k , i ) * a ( k , j ) end do f = s / h do k = i , m a ( k , j ) = a ( k , j ) + f * a ( k , i ) end do end do do k = i , m a ( k , i ) = scale * a ( k , i ) end do endif endif w ( i ) = scale * g g = 0.0_dp s = 0.0_dp scale = 0.0_dp if (( i . le . m ) . and . ( i . ne . n )) then do k = l , n scale = scale + abs ( a ( i , k )) end do if ( scale . ne . 0.0_dp ) then do k = l , n a ( i , k ) = a ( i , k ) / scale s = s + a ( i , k ) * a ( i , k ) end do f = a ( i , l ) g = - sign ( sqrt ( s ), f ) h = f * g - s a ( i , l ) = f - g do k = l , n rv1 ( k ) = a ( i , k ) / h end do do j = l , m s = 0.0_dp do k = l , n s = s + a ( j , k ) * a ( i , k ) end do do k = l , n a ( j , k ) = a ( j , k ) + s * rv1 ( k ) end do end do do k = l , n a ( i , k ) = scale * a ( i , k ) end do endif endif anorm = max ( anorm , ( abs ( w ( i )) + abs ( rv1 ( i )))) end do do i = n , 1 , - 1 if ( i . lt . n ) then if ( g . ne . 0.0_dp ) then do j = l , n v ( j , i ) = ( a ( i , j ) / a ( i , l )) / g end do do j = l , n s = 0.0_dp do k = l , n s = s + a ( i , k ) * v ( k , j ) end do do k = l , n v ( k , j ) = v ( k , j ) + s * v ( k , i ) end do end do endif do j = l , n v ( i , j ) = 0.0_dp v ( j , i ) = 0.0_dp end do endif v ( i , i ) = 1.0_dp g = rv1 ( i ) l = i end do do i = min ( m , n ), 1 , - 1 l = i + 1 g = w ( i ) do j = l , n a ( i , j ) = 0.0_dp end do if ( g . ne . 0.0_dp ) then g = 1.0_dp / g do j = l , n s = 0.0_dp do k = l , m s = s + a ( k , i ) * a ( k , j ) end do f = ( s / a ( i , i )) * g do k = i , m a ( k , j ) = a ( k , j ) + f * a ( k , i ) end do end do do j = i , m a ( j , i ) = a ( j , i ) * g end do else do j = i , m a ( j , i ) = 0.0_dp end do endif a ( i , i ) = a ( i , i ) + 1.0_dp end do do k = n , 1 , - 1 do its = 1 , 30 do l = k , 1 , - 1 nm = l - 1 if (( abs ( rv1 ( l )) + anorm ) . eq . anorm ) goto 2 if (( abs ( w ( nm )) + anorm ) . eq . anorm ) goto 1 end do 1 c = 0.0_dp s = 1.0_dp do i = l , k f = s * rv1 ( i ) rv1 ( i ) = c * rv1 ( i ) if (( abs ( f ) + anorm ) . eq . anorm ) goto 2 g = w ( i ) h = pythag ( f , g ) w ( i ) = h h = 1.0_dp / h c = ( g * h ) s = - ( f * h ) do j = 1 , m y = a ( j , nm ) z = a ( j , i ) a ( j , nm ) = ( y * c ) + ( z * s ) a ( j , i ) = - ( y * s ) + ( z * c ) end do end do 2 z = w ( k ) if ( l . eq . k ) then if ( z . lt . 0.0_dp ) then w ( k ) = - z do j = 1 , n v ( j , k ) = - v ( j , k ) end do endif goto 3 endif if ( its . eq . 30 ) then error stop 'no convergence in svdcmp' endif x = w ( l ) nm = k - 1 y = w ( nm ) g = rv1 ( nm ) h = rv1 ( k ) f = (( y - z ) * ( y + z ) + ( g - h ) * ( g + h )) / ( 2.0_dp * h * y ) g = pythag ( f , 1.0_dp ) f = (( x - z ) * ( x + z ) + h * (( y / ( f + sign ( g , f ))) - h )) / x c = 1.0_dp s = 1.0_dp do j = l , nm i = j + 1 g = rv1 ( i ) y = w ( i ) h = s * g g = c * g z = pythag ( f , h ) rv1 ( j ) = z c = f / z s = h / z f = ( x * c ) + ( g * s ) g = - ( x * s ) + ( g * c ) h = y * s y = y * c do jj = 1 , n x = v ( jj , j ) z = v ( jj , i ) v ( jj , j ) = ( x * c ) + ( z * s ) v ( jj , i ) = - ( x * s ) + ( z * c ) end do z = pythag ( f , h ) w ( j ) = z if ( z . ne . 0.0_dp ) then z = 1.0_dp / z c = f * z s = h * z endif f = ( c * g ) + ( s * y ) x = - ( s * g ) + ( c * y ) do jj = 1 , m y = a ( jj , j ) z = a ( jj , i ) a ( jj , j ) = ( y * c ) + ( z * s ) a ( jj , i ) = - ( y * s ) + ( z * c ) end do end do rv1 ( l ) = 0.0_dp rv1 ( k ) = f w ( k ) = x end do 3 continue end do end subroutine svdcmp elemental function pythag ( a , b ) real ( dp ), intent ( in ) :: a , b real ( dp ) :: pythag real ( dp ) :: absa , absb absa = abs ( a ) absb = abs ( b ) if ( absa . gt . absb ) then pythag = absa * dsqrt ( 1.0_dp + ( absb / absa ) ** 2 ) else if ( absb . eq . 0.0_dp ) then pythag = 0.0_dp else pythag = absb * dsqrt ( 1.0_dp + ( absa / absb ) ** 2 ) endif endif end function pythag end module rmsd_ls","tags":"","loc":"sourcefile/ls.f90.html"},{"title":"toml.f90 – mctc-rmsd","text":"Contents Modules rmsd_toml Source Code toml.f90 Source Code ! This file is part of mctc-rmsd. ! SPDX-Identifier: LGPL-3.0-or-later ! ! mctc-rmsd is free software: you can redistribute it and/or modify it under ! the terms of the GNU Lesser General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! mctc-rmsd is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU Lesser General Public License for more details. ! ! You should have received a copy of the GNU Lesser General Public License ! along with mctc-rmsd.  If not, see <https://www.gnu.org/licenses/>. !> Proxy interface to TOML-Fortran library module rmsd_toml use mctc_env , only : error_type , fatal_error use tomlf , only : toml_table , toml_array , toml_key , toml_stat , toml_error , & & toml_parse , toml_serializer , add_table , add_array , get_value , set_value , len implicit none private public :: read_config_file public :: toml_table , toml_array , toml_key , toml_stat , toml_serializer public :: add_table , add_array , get_value , set_value , len contains !> Process the configuration file to a TOML data structure subroutine read_config_file ( table , file , error ) !> TOML data structure type ( toml_table ), allocatable , intent ( out ) :: table !> Name of the configuration file character ( len =* ), intent ( in ) :: file !> Error status of the operation type ( error_type ), allocatable , intent ( out ) :: error type ( toml_error ), allocatable :: parse_error integer :: unit logical :: exist inquire ( file = file , exist = exist ) if (. not . exist ) then call fatal_error ( error , \"'\" // file // \"' not found\" ) return end if open ( file = file , newunit = unit ) call toml_parse ( table , unit , parse_error ) close ( unit ) if ( allocated ( parse_error )) then allocate ( error ) call move_alloc ( parse_error % message , error % message ) return end if end subroutine read_config_file end module rmsd_toml","tags":"","loc":"sourcefile/toml.f90.html"},{"title":"config.f90 – mctc-rmsd","text":"Contents Modules rmsd_config Source Code config.f90 Source Code ! This file is part of mctc-rmsd. ! SPDX-Identifier: LGPL-3.0-or-later ! ! mctc-rmsd is free software: you can redistribute it and/or modify it under ! the terms of the GNU Lesser General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! mctc-rmsd is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU Lesser General Public License for more details. ! ! You should have received a copy of the GNU Lesser General Public License ! along with mctc-rmsd.  If not, see <https://www.gnu.org/licenses/>. !> Configuration data for calculations of RMSDs between structures module rmsd_config use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : autoaa use rmsd_filter , only : rmsd_filter_type , new_rmsd_filter use rmsd_toml , only : toml_table , toml_array , toml_key , add_table , add_array , & & get_value , set_value , toml_stat implicit none private public :: rmsd_config_type , new_rmsd_config !> Configuration data for RMSD calculations type :: rmsd_config_type !> Error on mismatching structures logical :: strict !> Conversion factor for output real ( wp ) :: conv !> Length unit for RMSD output character ( len = :), allocatable :: length_unit !> Available RMSD filters type ( rmsd_filter_type ), allocatable :: filter (:) contains !> Select a filter from the configuration data procedure :: get_filter end type rmsd_config_type contains !> Create new configuration data from TOML data structure subroutine new_rmsd_config ( self , table , error ) !> Instance of the configuration data type ( rmsd_config_type ), intent ( out ) :: self !> TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_type ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child , child2 type ( toml_array ), pointer :: array integer :: stat call get_value ( table , \"strict\" , self % strict , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not error policy value from strict entry\" ) return end if call get_value ( table , \"unit\" , self % length_unit , \"AA\" ) if (. not . allocated ( self % length_unit )) then call fatal_error ( error , \"Could not retrieve length unit\" ) return end if call get_unit_conversion ( self % conv , self % length_unit , error ) if ( allocated ( error )) return call get_value ( table , \"filter\" , child , requested = . false .) if ( associated ( child )) then call new_rmsd_filter ( self % filter , child , error ) if ( allocated ( error )) return else call add_table ( table , \"filter\" , child ) call add_table ( child , \"heavy\" , child2 ) call add_array ( child2 , \"exclude\" , array ) call set_value ( array , 1 , \"H\" ) call set_value ( array , 2 , \"h\" ) call new_rmsd_filter ( self % filter , child , error ) if ( allocated ( error )) return end if end subroutine new_rmsd_config !> Get unit conversion factor from string subroutine get_unit_conversion ( conv , length_unit , error ) !> Conversion factor real ( wp ), intent ( out ) :: conv !> Length unit for RMSD output character ( len =* ), intent ( in ) :: length_unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error select case ( length_unit ) case default call fatal_error ( error , \"Unknown unit '\" // length_unit // \"' encountered\" ) case ( \"AA\" , \"Angstrom\" ) conv = autoaa case ( \"a0\" , \"Bohr\" ) conv = 1.0_wp end select end subroutine get_unit_conversion !> Retrieve filter from configuration data subroutine get_filter ( self , name , filter ) !> Instance of the configuration data class ( rmsd_config_type ), intent ( in ), target :: self !> Name of the filter character ( len =* ), intent ( in ) :: name !> Filter to use type ( rmsd_filter_type ), pointer :: filter integer :: i nullify ( filter ) if (. not . allocated ( self % filter )) return do i = 1 , size ( self % filter ) if ( name == self % filter ( i )% name ) then filter => self % filter ( i ) exit end if end do end subroutine get_filter end module rmsd_config","tags":"","loc":"sourcefile/config.f90.html"},{"title":"filter.f90 – mctc-rmsd","text":"Contents Modules rmsd_filter Source Code filter.f90 Source Code ! This file is part of mctc-rmsd. ! SPDX-Identifier: LGPL-3.0-or-later ! ! mctc-rmsd is free software: you can redistribute it and/or modify it under ! the terms of the GNU Lesser General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! mctc-rmsd is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU Lesser General Public License for more details. ! ! You should have received a copy of the GNU Lesser General Public License ! along with mctc-rmsd.  If not, see <https://www.gnu.org/licenses/>. !> Implementation of a filter type to store selection rules for molecular !> structure components based on atomic numbers and element symbols. module rmsd_filter use mctc_env_error , only : error_type , fatal_error use mctc_io_structure , only : structure_type use mctc_io_symbols , only : symbol_length , to_number use rmsd_toml , only : toml_table , toml_array , toml_key , get_value , toml_stat , & & len implicit none private public :: rmsd_filter_type , new_rmsd_filter !> Filter to allow selecting of atoms from a molecular structure type type :: rmsd_filter_type !> Name of the filter character ( len = :), allocatable :: name !> Atomic number integer , allocatable :: num (:) !> Element symbols character ( symbol_length ), allocatable :: sym (:) !> Whether the filter contains an allow or a deny list logical :: allow !> Use PDB identifiers for filtering logical :: pdb contains !> Create mask from filter and structure procedure :: get_mask end type rmsd_filter_type !> Overloaded constructor for RMSD filters interface new_rmsd_filter module procedure :: new_rmsd_filter_all module procedure :: new_rmsd_filter_one module procedure :: new_rmsd_filter_tbl end interface new_rmsd_filter contains !> Create a list of RMSD filters from a TOML data structure subroutine new_rmsd_filter_all ( self , table , error ) !> List of new species filters type ( rmsd_filter_type ), allocatable , intent ( out ) :: self (:) !> TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_type ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) type ( toml_table ), pointer :: child integer :: i call table % get_keys ( list ) allocate ( self ( size ( list ))) do i = 1 , size ( list ) call get_value ( table , list ( i )% key , child ) if (. not . associated ( child )) then call fatal_error ( error , \"Entry '\" // list ( i )% key // \"' is not a table\" ) exit end if call new_rmsd_filter ( self ( i ), child , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return end subroutine new_rmsd_filter_all !> Create a new RMSD filter from a TOML data structure subroutine new_rmsd_filter_tbl ( self , table , error ) !> Instance of species filter type ( rmsd_filter_type ), intent ( out ) :: self !> TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_type ), allocatable , intent ( out ) :: error type ( toml_array ), pointer :: array integer , allocatable :: num (:) character ( symbol_length ), allocatable :: sym (:) character ( len = :), allocatable :: name , cval integer :: ndim , inum , isym , ival , i , stat logical :: allow , pdb call table % get_key ( name ) call get_value ( table , \"pdb\" , pdb , . false .) call get_value ( table , \"include\" , array , requested = . false .) allow = associated ( array ) if (. not . allow ) then call get_value ( table , \"exclude\" , array , requested = . false .) if (. not . associated ( array )) then call fatal_error ( error , \"Filter '\" // name // \"' requires either an include or an exclude list\" ) return end if end if ndim = len ( array ) allocate ( num ( ndim )) allocate ( sym ( ndim )) isym = 0 inum = 0 do i = 1 , ndim call get_value ( array , i , ival , stat = stat ) if ( stat == toml_stat % success ) then if ( ival > 0 ) then inum = inum + 1 num ( inum ) = ival cycle else call fatal_error ( error , \"Atomic numbers must be larger than zero\" ) exit end if endif call get_value ( array , i , cval , stat = stat ) if ( stat == toml_stat % success ) then if ( to_number ( cval ) > 0 ) then isym = isym + 1 sym ( isym ) = cval cycle else call fatal_error ( error , \"Unknown element symbol '\" // cval // \"'\" ) exit end if end if call fatal_error ( error , \"Type mismatch for '\" // name // \"' filter\" ) exit end do if ( allocated ( error )) return call new_rmsd_filter ( self , name = name , num = num (: inum ), sym = sym (: isym ), & & allow = allow , pdb = pdb ) end subroutine new_rmsd_filter_tbl !> Create a new RMSD filter from parts subroutine new_rmsd_filter_one ( self , name , num , sym , allow , pdb ) !> Instance of species filter type ( rmsd_filter_type ), intent ( out ) :: self !> Name of the filter character ( len =* ), intent ( in ) :: name !> Whether the filter contains an allow or a deny list logical , intent ( in ) :: allow !> Filter is specific for PDB identifiers logical , intent ( in ) :: pdb !> Atomic number integer , intent ( in ) :: num (:) !> Element symbols character ( symbol_length ), intent ( in ) :: sym (:) self % name = name self % sym = sym self % num = num self % allow = allow self % pdb = pdb end subroutine new_rmsd_filter_one !> Create a logical mask for a given molecular structure type subroutine get_mask ( self , mol , mask ) !> Instance of species filter class ( rmsd_filter_type ), intent ( in ) :: self !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: mol !> Filter make logical , allocatable , intent ( out ) :: mask (:) logical , allocatable :: tmp (:) integer :: iat , izp allocate ( tmp ( mol % nid )) if ( self % allow ) then do izp = 1 , mol % nid tmp ( izp ) = any ( mol % num ( izp ) == self % num ) & & . or . any ( mol % sym ( izp ) == self % sym ) end do else do izp = 1 , mol % nid tmp ( izp ) = all ( mol % num ( izp ) /= self % num ) & & . and . all ( mol % sym ( izp ) /= self % sym ) end do end if allocate ( mask ( mol % nat )) do iat = 1 , mol % nat izp = mol % id ( iat ) mask ( iat ) = tmp ( izp ) end do if ( self % pdb . and . allocated ( mol % pdb )) then if ( self % allow ) then do iat = 1 , mol % nat mask ( iat ) = mask ( iat ) . or . any ( mol % pdb ( iat )% name == self % sym ) end do else do iat = 1 , mol % nat mask ( iat ) = mask ( iat ) . and . all ( mol % pdb ( iat )% name /= self % sym ) end do end if end if end subroutine get_mask end module rmsd_filter","tags":"","loc":"sourcefile/filter.f90.html"},{"title":"main.f90 – mctc-rmsd","text":"Contents Programs rmsd_main Source Code main.f90 Source Code ! This file is part of mctc-rmsd. ! SPDX-Identifier: LGPL-3.0-or-later ! ! mctc-rmsd is free software: you can redistribute it and/or modify it under ! the terms of the GNU Lesser General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! mctc-rmsd is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU Lesser General Public License for more details. ! ! You should have received a copy of the GNU Lesser General Public License ! along with mctc-rmsd.  If not, see <https://www.gnu.org/licenses/>. program rmsd_main use , intrinsic :: iso_fortran_env , only : output_unit , error_unit use mctc_env use mctc_io use targ use rmsd use rmsd_toml use rmsd_config use rmsd_filter implicit none character ( len =* ), parameter :: prog_name = \"mctc-rmsd\" interface read_structure procedure :: read_structure_from_arg end interface read_structure integer :: iarg , stat type ( arg_type ), allocatable :: args (:) type ( error_type ), allocatable :: error type ( structure_type ) :: ref , mol type ( rmsd_config_type ) :: config type ( rmsd_filter_type ), pointer :: filter type ( toml_table ), allocatable :: table , opts type ( toml_table ), pointer :: child type ( toml_serializer ) :: ser character ( len = :), allocatable :: rcfile , filter_name real ( wp ) :: rmsd_val type ( targ_type ) :: argparse logical :: show_version , show_help , show_rc logical , allocatable :: mask (:) argparse = new_argument_parser () call argparse % add_option ( \"help\" ) call argparse % add_option ( \"version\" ) call argparse % add_option ( \"rc\" ) call argparse % add_option ( \"filter\" , require = 1 ) call get_arguments ( args ) call get_options ( argparse , args , opts ) call get_value ( opts , \"filter\" , filter_name ) call get_value ( opts , \"version\" , show_version , . false .) call get_value ( opts , \"rc\" , show_rc , . false .) call get_value ( opts , \"help\" , show_help , size ( args ) <= 1 . and . . not . show_rc ) call opts % destroy if ( show_version ) then call version ( output_unit ) stop end if if ( show_help ) then call help ( output_unit ) if ( size ( args ) <= 1 ) error stop stop end if call get_config_file ( rcfile ) if ( allocated ( rcfile )) then call read_config_file ( table , rcfile , error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if else table = toml_table () end if call get_value ( table , \"rmsd\" , child , requested = . true .) if ( associated ( child )) then call new_rmsd_config ( config , child , error ) else call fatal_error ( error , \"Type mismatch, rmsd must be a table\" ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( show_rc ) then if ( allocated ( rcfile )) then write ( output_unit , '(*(a:, 1x))' ) \"#\" , \"configuration file:\" , rcfile else write ( output_unit , '(*(a:, 1x))' ) \"#\" , \"internal defaults\" end if ser = toml_serializer ( output_unit ) call table % accept ( ser ) stop end if nullify ( filter ) if ( allocated ( filter_name )) then call config % get_filter ( filter_name , filter ) if (. not . associated ( filter )) then write ( error_unit , '(a)' ) & & \"No filter with name '\" // filter_name // \"' present\" error stop end if end if call read_structure ( ref , args ( 1 ), error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( associated ( filter )) then call filter % get_mask ( ref , mask ) end if stat = 0 do iarg = 2 , size ( args ) call read_structure ( mol , args ( iarg ), error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message stat = stat + 1 cycle end if if ( config % strict ) then if ( ref % nat /= mol % nat ) then write ( error_unit , '(a)' ) & \"Number of atoms for '\" // args ( iarg )% arg // \"' mismatch with reference\" stat = stat + 1 cycle end if if ( any ( ref % num ( ref % id ) /= mol % num ( mol % id ))) then write ( error_unit , '(a)' ) & \"Atomic number of '\" // args ( iarg )% arg // \"' mismatch with reference\" stat = stat + 1 cycle end if end if if ( allocated ( error )) then stat = stat + 1 cycle end if call get_rmsd ( ref , mol , rmsd_val , mask = mask ) write ( output_unit , '(a, t40, es20.10, 1x, a)' ) & & args ( iarg )% arg , rmsd_val * config % conv , config % length_unit end do if ( stat > 0 ) then error stop end if contains subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <file> <file>...\" write ( unit , '(a)' ) & \"\" , & \"Requires at least two input files. Supported formats are:\" , & \"- xyz, mol, sdf, coord (0D), gen (C), pdb\" , & \"\" , & \"Configuration data is read from [rmsd] table in mctc.toml.\" , & \"Just place the configuration file mctc.toml (or .mctc.toml) in your home directory.\" , & \"Example:\" , & \"\" , & \"    [rmsd]\" , & \"    unit = \"\"AA\"\"\" , & \"    [rmsd.filter]\" , & \"    heavy.exclude = [ \"\"H\"\", \"\"h\"\" ]\" , & \"\" , & \"Options\" , & \"-------\" , & \"\" write ( unit , '(3x, a, t25, a)' ) & \"--filter <name>\" , \"Use <name> filter from configuration data to apply mask\" , & \"--rc\" , \"check configuration data and print it to standard out\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) & \"\" , & \"Filter\" , & \"------\" , & \"\" , & \"Filters can be defined in the [rmsd.filter] section, they take a list of\" , & \"atomic numbers and/or element symbols to define the allow-/deny-list.\" , & \"For example, to only check all carbon, nitrogen and oxygen atoms create\" , & \"a filter named organic with:\" , & \"\" , & \"    organic.include = [6, 7, 8]\" , & \"\" , & \"Similarly, to create a filter for all heavy elements, effectively just\" , & \"excluding hydrogen with standard symbols, use:\" , & \"\" , & \"    heavy.exclude = [\"\"H\"\", \"\"h\"\"]\" , & \"\" , & \"Note that this approach will still consider deuterium labeled as D,\" , & \"which would be excluded as well when using the atomic number instead.\" , & \"\" , & \"To create a PDB specific filter use the four character PDB identifier\" , & \"of the atoms and enable the PDB functionality.\" , & \"To match only the proteine backbone use\" , & \"\" , & \"    c-alpha.include = [\"\" CA \"\", \"\" N  \"\", \"\" C  \"\", \"\" O  \"\"]\" , & \"    c-alpha.pdb = true\" , & \"\" , & \"Atomic numbers and element symbols can be included here as well.\" , & \"\" end subroutine help subroutine read_structure_from_arg ( self , arg , error ) type ( structure_type ), intent ( out ) :: self type ( arg_type ), intent ( in ) :: arg type ( error_type ), allocatable , intent ( out ) :: error call read_structure ( self , arg % arg , error ) end subroutine read_structure_from_arg subroutine get_variable ( var , val ) !> Name of variable character ( len =* ), intent ( in ) :: var !> Value of variable character ( len = :), allocatable , intent ( out ) :: val integer :: length , stat call get_environment_variable ( var , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: val , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_environment_variable ( var , val , status = stat ) if ( stat /= 0 ) then deallocate ( val ) return end if end if end subroutine get_variable subroutine get_config_file ( config ) !> Name of the configuration file character ( len = :), allocatable , intent ( out ) :: config character ( len =* ), parameter :: rc = 'mctc.toml' character ( len = :), allocatable :: tmp , prefix character :: sep logical :: exist if ( is_windows ()) then sep = '\\' call get_variable(' HOME ', prefix) else sep = ' / ' call get_variable(' HOMEDIR ', prefix) end if if (allocated(prefix)) then tmp = prefix // sep // rc inquire(file=tmp, exist=exist) if (exist) then config = tmp return end if tmp = prefix // sep // ' . ' // rc inquire(file=tmp, exist=exist) if (exist) then config = tmp return end if end if inquire(file=rc, exist=exist) if (exist) then config = rc return end if end subroutine get_config_file !> Try to determine if we run on Windows and don' t have POSIX compliance around function is_windows () result ( windows ) !> Operating system seems to be Windows logical :: windows character ( len = :), allocatable :: tmp windows = . false . call get_variable ( 'OS' , tmp ) if ( allocated ( tmp )) then windows = index ( tmp , 'Windows_NT' ) > 0 end if if (. not . windows ) then call get_variable ( 'OSTYPE' , tmp ) if ( allocated ( tmp )) then windows = index ( tmp , 'win' ) > 0 . or . index ( tmp , 'msys' ) > 0 end if end if end function is_windows subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_rmsd_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version end program rmsd_main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"targ.f90 – mctc-rmsd","text":"Contents Modules targ Source Code targ.f90 Source Code ! SPDX-Identifier: LGPL-3.0-or-later module targ use tomlf implicit none private public :: arg_type , targ_type public :: get_arguments , new_argument_parser , get_options type :: arg_type character ( len = :), allocatable :: arg end type arg_type type :: opt_type character ( len = :), allocatable :: name integer :: require end type opt_type type :: targ_type integer :: nopt type ( opt_type ), allocatable :: opt (:) contains procedure :: add_option end type targ_type integer , parameter :: initial_size = 16 contains subroutine get_arguments ( args ) type ( arg_type ), allocatable , intent ( out ) :: args (:) integer :: iarg , length character ( len = :), allocatable :: tmp allocate ( args ( command_argument_count ())) do iarg = 1 , size ( args ) call get_command_argument ( iarg , length = length ) allocate ( character ( len = length ) :: tmp ) if ( length > 0 ) then call get_command_argument ( iarg , tmp ) end if call move_alloc ( tmp , args ( iarg )% arg ) end do end subroutine get_arguments subroutine get_options ( self , args , table ) type ( targ_type ), intent ( in ) :: self type ( arg_type ), allocatable , intent ( inout ) :: args (:) type ( arg_type ), allocatable :: tmp (:) type ( toml_table ), allocatable , intent ( out ) :: table type ( toml_array ), pointer :: array character ( len = :), allocatable :: arg integer :: iarg , ipos , iopt , ii logical :: getopts table = toml_table () allocate ( tmp ( size ( args ))) getopts = . true . ipos = 0 iarg = 0 do while ( iarg < size ( args )) iarg = iarg + 1 call move_alloc ( args ( iarg )% arg , arg ) if ( getopts ) then getopts = arg /= \"--\" if (. not . getopts ) cycle call match_option ( self , arg , iopt ) if ( iopt > 0 ) then select case ( self % opt ( iopt )% require ) case ( 0 ) call set_value ( table , self % opt ( iopt )% name , . true .) case ( 1 ) iarg = iarg + 1 if ( iarg <= size ( args )) then call set_value ( table , self % opt ( iopt )% name , args ( iarg )% arg ) end if case default if ( iarg + self % opt ( iopt )% require <= size ( args )) then call add_array ( table , self % opt ( iopt )% name , array ) do ii = 1 , self % opt ( iopt )% require call set_value ( array , ii , args ( iarg + ii )% arg ) end do iarg = iarg + self % opt ( iopt )% require end if end select cycle end if end if ipos = ipos + 1 call move_alloc ( arg , tmp ( ipos )% arg ) end do deallocate ( args ) allocate ( args ( ipos )) do ipos = 1 , size ( args ) call move_alloc ( tmp ( ipos )% arg , args ( ipos )% arg ) end do end subroutine get_options subroutine match_option ( self , arg , iopt ) type ( targ_type ), intent ( in ) :: self character ( len =* ), intent ( in ) :: arg integer , intent ( out ) :: iopt integer :: ii iopt = 0 do ii = 1 , self % nopt if ( self % opt ( ii )% name == arg ( 3 :)) then iopt = ii exit end if end do end subroutine match_option function new_argument_parser ( nopt ) result ( self ) integer , intent ( in ), optional :: nopt type ( targ_type ) :: self self % nopt = 0 if ( present ( nopt )) then allocate ( self % opt ( nopt )) else allocate ( self % opt ( initial_size )) end if end function new_argument_parser subroutine add_option ( self , name , require ) class ( targ_type ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ), optional :: require integer :: m m = size ( self % opt ) if ( self % nopt >= m ) then call resize ( self % opt , m + m / 2 + 1 ) end if self % nopt = self % nopt + 1 self % opt ( self % nopt )% name = name if ( present ( require )) then self % opt ( self % nopt )% require = require else self % opt ( self % nopt )% require = 0 end if end subroutine add_option subroutine resize ( list , n ) !> Array to be resized type ( opt_type ), allocatable , intent ( inout ), target :: list (:) !> New size of the list integer , intent ( in ) :: n type ( opt_type ), allocatable , target :: tmp (:) integer :: i if ( allocated ( list )) then call move_alloc ( list , tmp ) allocate ( list ( n )) do i = 1 , min ( size ( tmp ), n ) list ( i ) = tmp ( i ) end do deallocate ( tmp ) else allocate ( list ( n )) end if end subroutine resize end module targ","tags":"","loc":"sourcefile/targ.f90.html"},{"title":"rmsd_config_type – mctc-rmsd ","text":"type, public :: rmsd_config_type Configuration data for RMSD calculations Contents Variables conv filter length_unit strict Type-Bound Procedures get_filter Source Code rmsd_config_type Components Type Visibility Attributes Name Initial real(kind=wp), public :: conv Conversion factor for output type( rmsd_filter_type ), public, allocatable :: filter (:) Available RMSD filters character(len=:), public, allocatable :: length_unit Length unit for RMSD output logical, public :: strict Error on mismatching structures Type-Bound Procedures procedure, public :: get_filter Select a filter from the configuration data private subroutine get_filter(self, name, filter) Retrieve filter from configuration data Arguments Type Intent Optional Attributes Name class( rmsd_config_type ), intent(in), target :: self Instance of the configuration data character(len=*), intent(in) :: name Name of the filter type( rmsd_filter_type ), pointer :: filter Filter to use Source Code type :: rmsd_config_type !> Error on mismatching structures logical :: strict !> Conversion factor for output real ( wp ) :: conv !> Length unit for RMSD output character ( len = :), allocatable :: length_unit !> Available RMSD filters type ( rmsd_filter_type ), allocatable :: filter (:) contains !> Select a filter from the configuration data procedure :: get_filter end type rmsd_config_type","tags":"","loc":"type/rmsd_config_type.html"},{"title":"rmsd_filter_type – mctc-rmsd ","text":"type, public :: rmsd_filter_type Filter to allow selecting of atoms from a molecular structure type Contents Variables allow name num pdb sym Type-Bound Procedures get_mask Source Code rmsd_filter_type Components Type Visibility Attributes Name Initial logical, public :: allow Whether the filter contains an allow or a deny list character(len=:), public, allocatable :: name Name of the filter integer, public, allocatable :: num (:) Atomic number logical, public :: pdb Use PDB identifiers for filtering character(len=symbol_length), public, allocatable :: sym (:) Element symbols Type-Bound Procedures procedure, public :: get_mask Create mask from filter and structure private subroutine get_mask(self, mol, mask) Create a logical mask for a given molecular structure type Arguments Type Intent Optional Attributes Name class( rmsd_filter_type ), intent(in) :: self Instance of species filter class(structure_type), intent(in) :: mol Instance of the molecular structure data logical, intent(out), allocatable :: mask (:) Filter make Source Code type :: rmsd_filter_type !> Name of the filter character ( len = :), allocatable :: name !> Atomic number integer , allocatable :: num (:) !> Element symbols character ( symbol_length ), allocatable :: sym (:) !> Whether the filter contains an allow or a deny list logical :: allow !> Use PDB identifiers for filtering logical :: pdb contains !> Create mask from filter and structure procedure :: get_mask end type rmsd_filter_type","tags":"","loc":"type/rmsd_filter_type.html"},{"title":"arg_type – mctc-rmsd ","text":"type, public :: arg_type Contents Variables arg Source Code arg_type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: arg Source Code type :: arg_type character ( len = :), allocatable :: arg end type arg_type","tags":"","loc":"type/arg_type.html"},{"title":"targ_type – mctc-rmsd ","text":"type, public :: targ_type Contents Variables nopt opt Type-Bound Procedures add_option Source Code targ_type Components Type Visibility Attributes Name Initial integer, public :: nopt type(opt_type), public, allocatable :: opt (:) Type-Bound Procedures procedure, public :: add_option private subroutine add_option(self, name, require) Arguments Type Intent Optional Attributes Name class( targ_type ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in), optional :: require Source Code type :: targ_type integer :: nopt type ( opt_type ), allocatable :: opt (:) contains procedure :: add_option end type targ_type","tags":"","loc":"type/targ_type.html"},{"title":"get_rmsd – mctc-rmsd","text":"public interface get_rmsd Contents Module Procedures get_rmsd_for_structure Module Procedures private pure subroutine get_rmsd_for_structure(struc1, struc2, rmsd, gradient, trafo, mask) Arguments Type Intent Optional Attributes Name type(structure_type), intent(in) :: struc1 Reference structure type(structure_type), intent(in) :: struc2 Molecular structure to compare against real(kind=wp), intent(out) :: rmsd Root mean square deviation between the two structures real(kind=wp), intent(out), optional :: gradient (:,:) Gradient of the RMSD w.r.t. the coordinates real(kind=wp), intent(out), optional :: trafo (:,:) Rotation matrix between the two structures logical, intent(in), optional :: mask (:) Atoms to include in the RMSD calculation","tags":"","loc":"interface/get_rmsd.html"},{"title":"get_rmsd_version – mctc-rmsd","text":"public subroutine get_rmsd_version(major, minor, patch, string) Getter function to retrieve mctc-rmsd version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the mctc-rmsd version integer, intent(out), optional :: minor Minor version number of the mctc-rmsd version integer, intent(out), optional :: patch Patch version number of the mctc-rmsd version character(len=:), intent(out), optional allocatable :: string String representation of the mctc-rmsd version Contents Source Code get_rmsd_version Source Code subroutine get_rmsd_version ( major , minor , patch , string ) !> Major version number of the mctc-rmsd version integer , intent ( out ), optional :: major !> Minor version number of the mctc-rmsd version integer , intent ( out ), optional :: minor !> Patch version number of the mctc-rmsd version integer , intent ( out ), optional :: patch !> String representation of the mctc-rmsd version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = rmsd_version_compact ( 1 ) end if if ( present ( minor )) then minor = rmsd_version_compact ( 2 ) end if if ( present ( patch )) then patch = rmsd_version_compact ( 3 ) end if if ( present ( string )) then string = rmsd_version_string end if end subroutine get_rmsd_version","tags":"","loc":"proc/get_rmsd_version.html"},{"title":"get_rmsd – mctc-rmsd","text":"public interface get_rmsd Overload to allow extending the interface later Contents Module Procedures get_rmsd_for_coord Module Procedures private pure subroutine get_rmsd_for_coord(coord1, coord2, rmsd, gradient, trafo, mask) This subroutine calculates the least-square RMSD of two coordinate\n sets coord1(3, n) and coord2(3, n) using a method based on quaternion. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coord1 (:,:) Coordinates of the reference structure real(kind=dp), intent(in) :: coord2 (:,:) Coordinates of the structure to compare real(kind=dp), intent(out) :: rmsd Root mean square deviation between the input structure real(kind=dp), intent(out), optional :: gradient (:,:) Derivative of the RMSD w.r.t. the coordinates of the reference structure real(kind=dp), intent(out), optional :: trafo (:,:) Transformation matrix to rotate into reference structure logical, intent(in), optional :: mask (:) Atoms to include into RMSD calculation","tags":"","loc":"interface/get_rmsd~2.html"},{"title":"read_config_file – mctc-rmsd","text":"public subroutine read_config_file(table, file, error) Process the configuration file to a TOML data structure Arguments Type Intent Optional Attributes Name type(toml_table), intent(out), allocatable :: table TOML data structure character(len=*), intent(in) :: file Name of the configuration file type(error_type), intent(out), allocatable :: error Error status of the operation Contents Source Code read_config_file Source Code subroutine read_config_file ( table , file , error ) !> TOML data structure type ( toml_table ), allocatable , intent ( out ) :: table !> Name of the configuration file character ( len =* ), intent ( in ) :: file !> Error status of the operation type ( error_type ), allocatable , intent ( out ) :: error type ( toml_error ), allocatable :: parse_error integer :: unit logical :: exist inquire ( file = file , exist = exist ) if (. not . exist ) then call fatal_error ( error , \"'\" // file // \"' not found\" ) return end if open ( file = file , newunit = unit ) call toml_parse ( table , unit , parse_error ) close ( unit ) if ( allocated ( parse_error )) then allocate ( error ) call move_alloc ( parse_error % message , error % message ) return end if end subroutine read_config_file","tags":"","loc":"proc/read_config_file.html"},{"title":"new_rmsd_config – mctc-rmsd","text":"public subroutine new_rmsd_config(self, table, error) Create new configuration data from TOML data structure Arguments Type Intent Optional Attributes Name type( rmsd_config_type ), intent(out) :: self Instance of the configuration data type(toml_table), intent(inout) :: table TOML data structure type(error_type), intent(out), allocatable :: error Error handling Contents Source Code new_rmsd_config Source Code subroutine new_rmsd_config ( self , table , error ) !> Instance of the configuration data type ( rmsd_config_type ), intent ( out ) :: self !> TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_type ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child , child2 type ( toml_array ), pointer :: array integer :: stat call get_value ( table , \"strict\" , self % strict , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not error policy value from strict entry\" ) return end if call get_value ( table , \"unit\" , self % length_unit , \"AA\" ) if (. not . allocated ( self % length_unit )) then call fatal_error ( error , \"Could not retrieve length unit\" ) return end if call get_unit_conversion ( self % conv , self % length_unit , error ) if ( allocated ( error )) return call get_value ( table , \"filter\" , child , requested = . false .) if ( associated ( child )) then call new_rmsd_filter ( self % filter , child , error ) if ( allocated ( error )) return else call add_table ( table , \"filter\" , child ) call add_table ( child , \"heavy\" , child2 ) call add_array ( child2 , \"exclude\" , array ) call set_value ( array , 1 , \"H\" ) call set_value ( array , 2 , \"h\" ) call new_rmsd_filter ( self % filter , child , error ) if ( allocated ( error )) return end if end subroutine new_rmsd_config","tags":"","loc":"proc/new_rmsd_config.html"},{"title":"new_rmsd_filter – mctc-rmsd","text":"public interface new_rmsd_filter Overloaded constructor for RMSD filters Contents Module Procedures new_rmsd_filter_all new_rmsd_filter_one new_rmsd_filter_tbl Module Procedures private subroutine new_rmsd_filter_all(self, table, error) Create a list of RMSD filters from a TOML data structure Arguments Type Intent Optional Attributes Name type( rmsd_filter_type ), intent(out), allocatable :: self (:) List of new species filters type(toml_table), intent(inout) :: table TOML data structure type(error_type), intent(out), allocatable :: error Error handling private subroutine new_rmsd_filter_one(self, name, num, sym, allow, pdb) Create a new RMSD filter from parts Arguments Type Intent Optional Attributes Name type( rmsd_filter_type ), intent(out) :: self Instance of species filter character(len=*), intent(in) :: name Name of the filter integer, intent(in) :: num (:) Atomic number character(len=symbol_length), intent(in) :: sym (:) Element symbols logical, intent(in) :: allow Whether the filter contains an allow or a deny list logical, intent(in) :: pdb Filter is specific for PDB identifiers private subroutine new_rmsd_filter_tbl(self, table, error) Create a new RMSD filter from a TOML data structure Arguments Type Intent Optional Attributes Name type( rmsd_filter_type ), intent(out) :: self Instance of species filter type(toml_table), intent(inout) :: table TOML data structure type(error_type), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/new_rmsd_filter.html"},{"title":"is_windows – mctc-rmsd","text":"function is_windows() result(windows) Try to determine if we run on Windows and don’t have POSIX compliance around Arguments None Return Value logical Operating system seems to be Windows Contents Source Code is_windows Source Code function is_windows () result ( windows ) !> Operating system seems to be Windows logical :: windows character ( len = :), allocatable :: tmp windows = . false . call get_variable ( 'OS' , tmp ) if ( allocated ( tmp )) then windows = index ( tmp , 'Windows_NT' ) > 0 end if if (. not . windows ) then call get_variable ( 'OSTYPE' , tmp ) if ( allocated ( tmp )) then windows = index ( tmp , 'win' ) > 0 . or . index ( tmp , 'msys' ) > 0 end if end if end function is_windows","tags":"","loc":"proc/is_windows.html"},{"title":"get_config_file – mctc-rmsd","text":"subroutine get_config_file(config) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: config Name of the configuration file Contents Source Code get_config_file Source Code subroutine get_config_file ( config ) !> Name of the configuration file character ( len = :), allocatable , intent ( out ) :: config character ( len =* ), parameter :: rc = 'mctc.toml' character ( len = :), allocatable :: tmp , prefix character :: sep logical :: exist if ( is_windows ()) then sep = '\\' call get_variable(' HOME ', prefix) else sep = ' / ' call get_variable(' HOMEDIR ', prefix) end if if (allocated(prefix)) then tmp = prefix // sep // rc inquire(file=tmp, exist=exist) if (exist) then config = tmp return end if tmp = prefix // sep // ' . ' // rc inquire ( file = tmp , exist = exist ) if ( exist ) then config = tmp return end if end if inquire ( file = rc , exist = exist ) if ( exist ) then config = rc return end if end subroutine get_config_file","tags":"","loc":"proc/get_config_file.html"},{"title":"get_variable – mctc-rmsd","text":"subroutine get_variable(var, val) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Name of variable character(len=:), intent(out), allocatable :: val Value of variable Contents Source Code get_variable Source Code subroutine get_variable ( var , val ) !> Name of variable character ( len =* ), intent ( in ) :: var !> Value of variable character ( len = :), allocatable , intent ( out ) :: val integer :: length , stat call get_environment_variable ( var , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: val , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_environment_variable ( var , val , status = stat ) if ( stat /= 0 ) then deallocate ( val ) return end if end if end subroutine get_variable","tags":"","loc":"proc/get_variable.html"},{"title":"help – mctc-rmsd","text":"subroutine help(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Contents Source Code help Source Code subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <file> <file>...\" write ( unit , '(a)' ) & \"\" , & \"Requires at least two input files. Supported formats are:\" , & \"- xyz, mol, sdf, coord (0D), gen (C), pdb\" , & \"\" , & \"Configuration data is read from [rmsd] table in mctc.toml.\" , & \"Just place the configuration file mctc.toml (or .mctc.toml) in your home directory.\" , & \"Example:\" , & \"\" , & \"    [rmsd]\" , & \"    unit = \"\"AA\"\"\" , & \"    [rmsd.filter]\" , & \"    heavy.exclude = [ \"\"H\"\", \"\"h\"\" ]\" , & \"\" , & \"Options\" , & \"-------\" , & \"\" write ( unit , '(3x, a, t25, a)' ) & \"--filter <name>\" , \"Use <name> filter from configuration data to apply mask\" , & \"--rc\" , \"check configuration data and print it to standard out\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) & \"\" , & \"Filter\" , & \"------\" , & \"\" , & \"Filters can be defined in the [rmsd.filter] section, they take a list of\" , & \"atomic numbers and/or element symbols to define the allow-/deny-list.\" , & \"For example, to only check all carbon, nitrogen and oxygen atoms create\" , & \"a filter named organic with:\" , & \"\" , & \"    organic.include = [6, 7, 8]\" , & \"\" , & \"Similarly, to create a filter for all heavy elements, effectively just\" , & \"excluding hydrogen with standard symbols, use:\" , & \"\" , & \"    heavy.exclude = [\"\"H\"\", \"\"h\"\"]\" , & \"\" , & \"Note that this approach will still consider deuterium labeled as D,\" , & \"which would be excluded as well when using the atomic number instead.\" , & \"\" , & \"To create a PDB specific filter use the four character PDB identifier\" , & \"of the atoms and enable the PDB functionality.\" , & \"To match only the proteine backbone use\" , & \"\" , & \"    c-alpha.include = [\"\" CA \"\", \"\" N  \"\", \"\" C  \"\", \"\" O  \"\"]\" , & \"    c-alpha.pdb = true\" , & \"\" , & \"Atomic numbers and element symbols can be included here as well.\" , & \"\" end subroutine help","tags":"","loc":"proc/help.html"},{"title":"read_structure_from_arg – mctc-rmsd","text":"subroutine read_structure_from_arg(self, arg, error) Arguments Type Intent Optional Attributes Name type(structure_type), intent(out) :: self type( arg_type ), intent(in) :: arg type(error_type), intent(out), allocatable :: error Contents Source Code read_structure_from_arg Source Code subroutine read_structure_from_arg ( self , arg , error ) type ( structure_type ), intent ( out ) :: self type ( arg_type ), intent ( in ) :: arg type ( error_type ), allocatable , intent ( out ) :: error call read_structure ( self , arg % arg , error ) end subroutine read_structure_from_arg","tags":"","loc":"proc/read_structure_from_arg.html"},{"title":"version – mctc-rmsd","text":"subroutine version(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Contents Source Code version Source Code subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_rmsd_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version","tags":"","loc":"proc/version.html"},{"title":"read_structure – mctc-rmsd","text":"public interface read_structure Contents Module Procedures read_structure_from_arg Module Procedures subroutine read_structure_from_arg (self, arg, error) Arguments Type Intent Optional Attributes Name type(structure_type), intent(out) :: self type( arg_type ), intent(in) :: arg type(error_type), intent(out), allocatable :: error","tags":"","loc":"interface/read_structure.html"},{"title":"new_argument_parser – mctc-rmsd","text":"public function new_argument_parser(nopt) result(self) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: nopt Return Value type( targ_type ) Contents Source Code new_argument_parser Source Code function new_argument_parser ( nopt ) result ( self ) integer , intent ( in ), optional :: nopt type ( targ_type ) :: self self % nopt = 0 if ( present ( nopt )) then allocate ( self % opt ( nopt )) else allocate ( self % opt ( initial_size )) end if end function new_argument_parser","tags":"","loc":"proc/new_argument_parser.html"},{"title":"get_arguments – mctc-rmsd","text":"public subroutine get_arguments(args) Arguments Type Intent Optional Attributes Name type( arg_type ), intent(out), allocatable :: args (:) Contents Source Code get_arguments Source Code subroutine get_arguments ( args ) type ( arg_type ), allocatable , intent ( out ) :: args (:) integer :: iarg , length character ( len = :), allocatable :: tmp allocate ( args ( command_argument_count ())) do iarg = 1 , size ( args ) call get_command_argument ( iarg , length = length ) allocate ( character ( len = length ) :: tmp ) if ( length > 0 ) then call get_command_argument ( iarg , tmp ) end if call move_alloc ( tmp , args ( iarg )% arg ) end do end subroutine get_arguments","tags":"","loc":"proc/get_arguments.html"},{"title":"get_options – mctc-rmsd","text":"public subroutine get_options(self, args, table) Arguments Type Intent Optional Attributes Name type( targ_type ), intent(in) :: self type( arg_type ), intent(inout), allocatable :: args (:) type(toml_table), intent(out), allocatable :: table Contents Source Code get_options Source Code subroutine get_options ( self , args , table ) type ( targ_type ), intent ( in ) :: self type ( arg_type ), allocatable , intent ( inout ) :: args (:) type ( arg_type ), allocatable :: tmp (:) type ( toml_table ), allocatable , intent ( out ) :: table type ( toml_array ), pointer :: array character ( len = :), allocatable :: arg integer :: iarg , ipos , iopt , ii logical :: getopts table = toml_table () allocate ( tmp ( size ( args ))) getopts = . true . ipos = 0 iarg = 0 do while ( iarg < size ( args )) iarg = iarg + 1 call move_alloc ( args ( iarg )% arg , arg ) if ( getopts ) then getopts = arg /= \"--\" if (. not . getopts ) cycle call match_option ( self , arg , iopt ) if ( iopt > 0 ) then select case ( self % opt ( iopt )% require ) case ( 0 ) call set_value ( table , self % opt ( iopt )% name , . true .) case ( 1 ) iarg = iarg + 1 if ( iarg <= size ( args )) then call set_value ( table , self % opt ( iopt )% name , args ( iarg )% arg ) end if case default if ( iarg + self % opt ( iopt )% require <= size ( args )) then call add_array ( table , self % opt ( iopt )% name , array ) do ii = 1 , self % opt ( iopt )% require call set_value ( array , ii , args ( iarg + ii )% arg ) end do iarg = iarg + self % opt ( iopt )% require end if end select cycle end if end if ipos = ipos + 1 call move_alloc ( arg , tmp ( ipos )% arg ) end do deallocate ( args ) allocate ( args ( ipos )) do ipos = 1 , size ( args ) call move_alloc ( tmp ( ipos )% arg , args ( ipos )% arg ) end do end subroutine get_options","tags":"","loc":"proc/get_options.html"},{"title":"rmsd – mctc-rmsd","text":"Uses mctc_env mctc_io rmsd_ls rmsd_version Contents Interfaces get_rmsd Interfaces public interface get_rmsd private pure subroutine get_rmsd_for_structure(struc1, struc2, rmsd, gradient, trafo, mask) Arguments Type Intent Optional Attributes Name type(structure_type), intent(in) :: struc1 Reference structure type(structure_type), intent(in) :: struc2 Molecular structure to compare against real(kind=wp), intent(out) :: rmsd Root mean square deviation between the two structures real(kind=wp), intent(out), optional :: gradient (:,:) Gradient of the RMSD w.r.t. the coordinates real(kind=wp), intent(out), optional :: trafo (:,:) Rotation matrix between the two structures logical, intent(in), optional :: mask (:) Atoms to include in the RMSD calculation","tags":"","loc":"module/rmsd.html"},{"title":"rmsd_version – mctc-rmsd","text":"Versioning information on this library. Contents Variables rmsd_version_compact rmsd_version_string Subroutines get_rmsd_version Variables Type Visibility Attributes Name Initial integer, public, parameter :: rmsd_version_compact (3) = [0, 1, 1] Numeric representation of the mctc-rmsd version character(len=*), public, parameter :: rmsd_version_string = \"0.1.1\" String representation of the mctc-rmsd version Subroutines public subroutine get_rmsd_version (major, minor, patch, string) Getter function to retrieve mctc-rmsd version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the mctc-rmsd version integer, intent(out), optional :: minor Minor version number of the mctc-rmsd version integer, intent(out), optional :: patch Patch version number of the mctc-rmsd version character(len=:), intent(out), optional allocatable :: string String representation of the mctc-rmsd version","tags":"","loc":"module/rmsd_version.html"},{"title":"rmsd_ls – mctc-rmsd","text":"Implementation of the least-square RMSD fit of two structures Uses mctc_env_accuracy Contents Interfaces get_rmsd Interfaces public interface get_rmsd Overload to allow extending the interface later private pure subroutine get_rmsd_for_coord(coord1, coord2, rmsd, gradient, trafo, mask) This subroutine calculates the least-square RMSD of two coordinate\n sets coord1(3, n) and coord2(3, n) using a method based on quaternion. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coord1 (:,:) Coordinates of the reference structure real(kind=dp), intent(in) :: coord2 (:,:) Coordinates of the structure to compare real(kind=dp), intent(out) :: rmsd Root mean square deviation between the input structure real(kind=dp), intent(out), optional :: gradient (:,:) Derivative of the RMSD w.r.t. the coordinates of the reference structure real(kind=dp), intent(out), optional :: trafo (:,:) Transformation matrix to rotate into reference structure logical, intent(in), optional :: mask (:) Atoms to include into RMSD calculation","tags":"","loc":"module/rmsd_ls.html"},{"title":"rmsd_toml – mctc-rmsd","text":"Proxy interface to TOML-Fortran library Uses mctc_env tomlf Contents Subroutines read_config_file Subroutines public subroutine read_config_file (table, file, error) Process the configuration file to a TOML data structure Arguments Type Intent Optional Attributes Name type(toml_table), intent(out), allocatable :: table TOML data structure character(len=*), intent(in) :: file Name of the configuration file type(error_type), intent(out), allocatable :: error Error status of the operation","tags":"","loc":"module/rmsd_toml.html"},{"title":"rmsd_config – mctc-rmsd","text":"Configuration data for calculations of RMSDs between structures Uses mctc_env_accuracy mctc_env_error mctc_io_convert rmsd_filter rmsd_toml Contents Derived Types rmsd_config_type Subroutines new_rmsd_config Derived Types type, public :: rmsd_config_type Configuration data for RMSD calculations Components Type Visibility Attributes Name Initial real(kind=wp), public :: conv Conversion factor for output type( rmsd_filter_type ), public, allocatable :: filter (:) Available RMSD filters character(len=:), public, allocatable :: length_unit Length unit for RMSD output logical, public :: strict Error on mismatching structures Type-Bound Procedures procedure, public :: get_filter Select a filter from the configuration data Subroutines public subroutine new_rmsd_config (self, table, error) Create new configuration data from TOML data structure Arguments Type Intent Optional Attributes Name type( rmsd_config_type ), intent(out) :: self Instance of the configuration data type(toml_table), intent(inout) :: table TOML data structure type(error_type), intent(out), allocatable :: error Error handling","tags":"","loc":"module/rmsd_config.html"},{"title":"rmsd_filter – mctc-rmsd","text":"Implementation of a filter type to store selection rules for molecular\n structure components based on atomic numbers and element symbols. Uses mctc_env_error mctc_io_structure mctc_io_symbols rmsd_toml Contents Interfaces new_rmsd_filter Derived Types rmsd_filter_type Interfaces public interface new_rmsd_filter Overloaded constructor for RMSD filters private subroutine new_rmsd_filter_all(self, table, error) Create a list of RMSD filters from a TOML data structure Arguments Type Intent Optional Attributes Name type( rmsd_filter_type ), intent(out), allocatable :: self (:) List of new species filters type(toml_table), intent(inout) :: table TOML data structure type(error_type), intent(out), allocatable :: error Error handling private subroutine new_rmsd_filter_one(self, name, num, sym, allow, pdb) Create a new RMSD filter from parts Arguments Type Intent Optional Attributes Name type( rmsd_filter_type ), intent(out) :: self Instance of species filter character(len=*), intent(in) :: name Name of the filter integer, intent(in) :: num (:) Atomic number character(len=symbol_length), intent(in) :: sym (:) Element symbols logical, intent(in) :: allow Whether the filter contains an allow or a deny list logical, intent(in) :: pdb Filter is specific for PDB identifiers private subroutine new_rmsd_filter_tbl(self, table, error) Create a new RMSD filter from a TOML data structure Arguments Type Intent Optional Attributes Name type( rmsd_filter_type ), intent(out) :: self Instance of species filter type(toml_table), intent(inout) :: table TOML data structure type(error_type), intent(out), allocatable :: error Error handling Derived Types type, public :: rmsd_filter_type Filter to allow selecting of atoms from a molecular structure type Components Type Visibility Attributes Name Initial logical, public :: allow Whether the filter contains an allow or a deny list character(len=:), public, allocatable :: name Name of the filter integer, public, allocatable :: num (:) Atomic number logical, public :: pdb Use PDB identifiers for filtering character(len=symbol_length), public, allocatable :: sym (:) Element symbols Type-Bound Procedures procedure, public :: get_mask Create mask from filter and structure","tags":"","loc":"module/rmsd_filter.html"},{"title":"targ – mctc-rmsd","text":"Uses tomlf Contents Derived Types arg_type targ_type Functions new_argument_parser Subroutines get_arguments get_options Derived Types type, public :: arg_type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: arg type, public :: targ_type Components Type Visibility Attributes Name Initial integer, public :: nopt type(opt_type), public, allocatable :: opt (:) Type-Bound Procedures procedure, public :: add_option Functions public function new_argument_parser (nopt) result(self) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: nopt Return Value type( targ_type ) Subroutines public subroutine get_arguments (args) Arguments Type Intent Optional Attributes Name type( arg_type ), intent(out), allocatable :: args (:) public subroutine get_options (self, args, table) Arguments Type Intent Optional Attributes Name type( targ_type ), intent(in) :: self type( arg_type ), intent(inout), allocatable :: args (:) type(toml_table), intent(out), allocatable :: table","tags":"","loc":"module/targ.html"},{"title":"rmsd_main – mctc-rmsd","text":"Uses iso_fortran_env mctc_env mctc_io targ rmsd rmsd_toml rmsd_config rmsd_filter Contents Variables argparse args child config error filter filter_name iarg mask mol opts prog_name rcfile ref rmsd_val ser show_help show_rc show_version stat table Interfaces read_structure Functions is_windows Subroutines get_config_file get_variable help read_structure_from_arg version Source Code rmsd_main Variables Type Attributes Name Initial type( targ_type ) :: argparse type( arg_type ), allocatable :: args (:) type(toml_table), pointer :: child type( rmsd_config_type ) :: config type(error_type), allocatable :: error type( rmsd_filter_type ), pointer :: filter character(len=:), allocatable :: filter_name integer :: iarg logical, allocatable :: mask (:) type(structure_type) :: mol type(toml_table), allocatable :: opts character(len=*), parameter :: prog_name = \"mctc-rmsd\" character(len=:), allocatable :: rcfile type(structure_type) :: ref real(kind=wp) :: rmsd_val type(toml_serializer) :: ser logical :: show_help logical :: show_rc logical :: show_version integer :: stat type(toml_table), allocatable :: table Interfaces interface read_structure subroutine read_structure_from_arg (self, arg, error) Arguments Type Intent Optional Attributes Name type(structure_type), intent(out) :: self type( arg_type ), intent(in) :: arg type(error_type), intent(out), allocatable :: error Functions function is_windows () result(windows) Try to determine if we run on Windows and don’t have POSIX compliance around Arguments None Return Value logical Operating system seems to be Windows Subroutines subroutine get_config_file (config) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: config Name of the configuration file subroutine get_variable (var, val) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Name of variable character(len=:), intent(out), allocatable :: val Value of variable subroutine help (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit subroutine read_structure_from_arg (self, arg, error) Arguments Type Intent Optional Attributes Name type(structure_type), intent(out) :: self type( arg_type ), intent(in) :: arg type(error_type), intent(out), allocatable :: error subroutine version (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Source Code program rmsd_main use , intrinsic :: iso_fortran_env , only : output_unit , error_unit use mctc_env use mctc_io use targ use rmsd use rmsd_toml use rmsd_config use rmsd_filter implicit none character ( len =* ), parameter :: prog_name = \"mctc-rmsd\" interface read_structure procedure :: read_structure_from_arg end interface read_structure integer :: iarg , stat type ( arg_type ), allocatable :: args (:) type ( error_type ), allocatable :: error type ( structure_type ) :: ref , mol type ( rmsd_config_type ) :: config type ( rmsd_filter_type ), pointer :: filter type ( toml_table ), allocatable :: table , opts type ( toml_table ), pointer :: child type ( toml_serializer ) :: ser character ( len = :), allocatable :: rcfile , filter_name real ( wp ) :: rmsd_val type ( targ_type ) :: argparse logical :: show_version , show_help , show_rc logical , allocatable :: mask (:) argparse = new_argument_parser () call argparse % add_option ( \"help\" ) call argparse % add_option ( \"version\" ) call argparse % add_option ( \"rc\" ) call argparse % add_option ( \"filter\" , require = 1 ) call get_arguments ( args ) call get_options ( argparse , args , opts ) call get_value ( opts , \"filter\" , filter_name ) call get_value ( opts , \"version\" , show_version , . false .) call get_value ( opts , \"rc\" , show_rc , . false .) call get_value ( opts , \"help\" , show_help , size ( args ) <= 1 . and . . not . show_rc ) call opts % destroy if ( show_version ) then call version ( output_unit ) stop end if if ( show_help ) then call help ( output_unit ) if ( size ( args ) <= 1 ) error stop stop end if call get_config_file ( rcfile ) if ( allocated ( rcfile )) then call read_config_file ( table , rcfile , error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if else table = toml_table () end if call get_value ( table , \"rmsd\" , child , requested = . true .) if ( associated ( child )) then call new_rmsd_config ( config , child , error ) else call fatal_error ( error , \"Type mismatch, rmsd must be a table\" ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( show_rc ) then if ( allocated ( rcfile )) then write ( output_unit , '(*(a:, 1x))' ) \"#\" , \"configuration file:\" , rcfile else write ( output_unit , '(*(a:, 1x))' ) \"#\" , \"internal defaults\" end if ser = toml_serializer ( output_unit ) call table % accept ( ser ) stop end if nullify ( filter ) if ( allocated ( filter_name )) then call config % get_filter ( filter_name , filter ) if (. not . associated ( filter )) then write ( error_unit , '(a)' ) & & \"No filter with name '\" // filter_name // \"' present\" error stop end if end if call read_structure ( ref , args ( 1 ), error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( associated ( filter )) then call filter % get_mask ( ref , mask ) end if stat = 0 do iarg = 2 , size ( args ) call read_structure ( mol , args ( iarg ), error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message stat = stat + 1 cycle end if if ( config % strict ) then if ( ref % nat /= mol % nat ) then write ( error_unit , '(a)' ) & \"Number of atoms for '\" // args ( iarg )% arg // \"' mismatch with reference\" stat = stat + 1 cycle end if if ( any ( ref % num ( ref % id ) /= mol % num ( mol % id ))) then write ( error_unit , '(a)' ) & \"Atomic number of '\" // args ( iarg )% arg // \"' mismatch with reference\" stat = stat + 1 cycle end if end if if ( allocated ( error )) then stat = stat + 1 cycle end if call get_rmsd ( ref , mol , rmsd_val , mask = mask ) write ( output_unit , '(a, t40, es20.10, 1x, a)' ) & & args ( iarg )% arg , rmsd_val * config % conv , config % length_unit end do if ( stat > 0 ) then error stop end if contains subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <file> <file>...\" write ( unit , '(a)' ) & \"\" , & \"Requires at least two input files. Supported formats are:\" , & \"- xyz, mol, sdf, coord (0D), gen (C), pdb\" , & \"\" , & \"Configuration data is read from [rmsd] table in mctc.toml.\" , & \"Just place the configuration file mctc.toml (or .mctc.toml) in your home directory.\" , & \"Example:\" , & \"\" , & \"    [rmsd]\" , & \"    unit = \"\"AA\"\"\" , & \"    [rmsd.filter]\" , & \"    heavy.exclude = [ \"\"H\"\", \"\"h\"\" ]\" , & \"\" , & \"Options\" , & \"-------\" , & \"\" write ( unit , '(3x, a, t25, a)' ) & \"--filter <name>\" , \"Use <name> filter from configuration data to apply mask\" , & \"--rc\" , \"check configuration data and print it to standard out\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) & \"\" , & \"Filter\" , & \"------\" , & \"\" , & \"Filters can be defined in the [rmsd.filter] section, they take a list of\" , & \"atomic numbers and/or element symbols to define the allow-/deny-list.\" , & \"For example, to only check all carbon, nitrogen and oxygen atoms create\" , & \"a filter named organic with:\" , & \"\" , & \"    organic.include = [6, 7, 8]\" , & \"\" , & \"Similarly, to create a filter for all heavy elements, effectively just\" , & \"excluding hydrogen with standard symbols, use:\" , & \"\" , & \"    heavy.exclude = [\"\"H\"\", \"\"h\"\"]\" , & \"\" , & \"Note that this approach will still consider deuterium labeled as D,\" , & \"which would be excluded as well when using the atomic number instead.\" , & \"\" , & \"To create a PDB specific filter use the four character PDB identifier\" , & \"of the atoms and enable the PDB functionality.\" , & \"To match only the proteine backbone use\" , & \"\" , & \"    c-alpha.include = [\"\" CA \"\", \"\" N  \"\", \"\" C  \"\", \"\" O  \"\"]\" , & \"    c-alpha.pdb = true\" , & \"\" , & \"Atomic numbers and element symbols can be included here as well.\" , & \"\" end subroutine help subroutine read_structure_from_arg ( self , arg , error ) type ( structure_type ), intent ( out ) :: self type ( arg_type ), intent ( in ) :: arg type ( error_type ), allocatable , intent ( out ) :: error call read_structure ( self , arg % arg , error ) end subroutine read_structure_from_arg subroutine get_variable ( var , val ) !> Name of variable character ( len =* ), intent ( in ) :: var !> Value of variable character ( len = :), allocatable , intent ( out ) :: val integer :: length , stat call get_environment_variable ( var , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: val , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_environment_variable ( var , val , status = stat ) if ( stat /= 0 ) then deallocate ( val ) return end if end if end subroutine get_variable subroutine get_config_file ( config ) !> Name of the configuration file character ( len = :), allocatable , intent ( out ) :: config character ( len =* ), parameter :: rc = 'mctc.toml' character ( len = :), allocatable :: tmp , prefix character :: sep logical :: exist if ( is_windows ()) then sep = '\\' call get_variable(' HOME ', prefix) else sep = ' / ' call get_variable(' HOMEDIR ', prefix) end if if (allocated(prefix)) then tmp = prefix // sep // rc inquire(file=tmp, exist=exist) if (exist) then config = tmp return end if tmp = prefix // sep // ' . ' // rc inquire(file=tmp, exist=exist) if (exist) then config = tmp return end if end if inquire(file=rc, exist=exist) if (exist) then config = rc return end if end subroutine get_config_file !> Try to determine if we run on Windows and don' t have POSIX compliance around function is_windows () result ( windows ) !> Operating system seems to be Windows logical :: windows character ( len = :), allocatable :: tmp windows = . false . call get_variable ( 'OS' , tmp ) if ( allocated ( tmp )) then windows = index ( tmp , 'Windows_NT' ) > 0 end if if (. not . windows ) then call get_variable ( 'OSTYPE' , tmp ) if ( allocated ( tmp )) then windows = index ( tmp , 'win' ) > 0 . or . index ( tmp , 'msys' ) > 0 end if end if end function is_windows subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_rmsd_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version end program rmsd_main","tags":"","loc":"program/rmsd_main.html"}]}